import { createWriteStream } from 'node:fs';
import { lstat, mkdir, readFile, writeFile } from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';

import { Codex } from '@openai/codex-sdk';

import { handleImmediateFlag, printHelp } from './cli/help.js';
import {
  applyBooleanOption,
  isBooleanOption,
  isOption,
  parseArgs,
  parseBoolean,
  type ReasoningLevel,
  validateOptions,
} from './cli/options.js';
import { ensureCodexConfig } from './config/codex-config.js';
import { tailLogFile } from './logging/logging.js';
import { buildPrompt } from './prompts/prompt-builder.js';
import { listPromptRoles, resolvePromptTemplate } from './prompts/prompt-templates.js';
import { printFinalResponse, printSummaries } from './reporting/reporter.js';
import { resolveOutputSchema } from './schema/output-schema.js';
import {
  handleItemCompleted,
  handleTurnCompleted,
  processStream,
} from './stream/stream-processor.js';
import {
  isAgentMessage,
  isCommandExecution,
  isFileChangeArray,
  isFileChangeItem,
  isMcpToolCall,
  isString,
  isWebSearch,
  toStreamResults,
} from './stream/stream-results.js';
import type { DelegateOptions } from './types/delegate-options.js';

const DEFAULT_TIMEOUT_MINUTES = 10;
const LOG_TAIL_LINE_COUNT = 5;
const MILLISECONDS_PER_SECOND = 1000;
const SECONDS_PER_MINUTE = 60;
const STARTUP_ARG_OFFSET = 2;

/**
 * Read the Codex config if it exists.
 *
 * @param {string} configPath - Absolute path to the Codex config.
 * @returns {Promise<string | undefined>} Contents when readable, otherwise undefined.
 */
async function readCodexConfig(configPath: string): Promise<string | undefined> {
  try {
    // eslint-disable-next-line security/detect-non-literal-fs-filename -- config path is derived from CODEX_HOME or defaults
    return await readFile(configPath, 'utf8');
  } catch {
    return undefined;
  }
}

/**
 * Ensure the local .codex directory is safe to write to.
 *
 * @param {string} codexDir - Working directory .codex path.
 * @returns {Promise<void>} Resolves when the directory is safe.
 * @throws {Error} When the directory is a symlink or the stat fails unexpectedly.
 */
async function ensureSafeCodexDir(codexDir: string): Promise<void> {
  try {
    // eslint-disable-next-line security/detect-non-literal-fs-filename -- codexDir is derived from the current working directory
    const stats = await lstat(codexDir);
    if (stats.isSymbolicLink()) {
      throw new Error('Refusing to write to .codex because it is a symbolic link.');
    }
  } catch (error) {
    if (error instanceof Error && 'code' in error && error.code !== 'ENOENT') {
      throw error;
    }
  }
}

/**
 * Ensure the fallback config exists at the given path.
 *
 * @param {string} fallbackConfigPath - Absolute path for the fallback config.
 * @returns {Promise<void>} Resolves when the file is present.
 */
async function ensureFallbackConfig(fallbackConfigPath: string): Promise<void> {
  try {
    // eslint-disable-next-line security/detect-non-literal-fs-filename -- fallback path is derived from the current working directory
    await readFile(fallbackConfigPath, 'utf8');
  } catch {
    // eslint-disable-next-line security/detect-non-literal-fs-filename -- fallback path is derived from the current working directory
    await writeFile(
      fallbackConfigPath,
      '# Generated by codex-delegate to avoid unsupported wire_api values.\n',
      'utf8',
    );
  }
}

/**
 * Copy the current process environment into a mutable object.
 *
 * @returns {Record<string, string>} Environment copy with only defined values.
 */
function cloneProcessEnv(): Record<string, string> {
  const env: Record<string, string> = {};
  for (const [key, value] of Object.entries(process.env)) {
    if (value !== undefined) {
      env[key] = value;
    }
  }
  return env;
}

/**
 * Build a safe environment for the Codex CLI when the host config contains unsupported values.
 *
 * @returns {Promise<Record<string, string> | undefined>} Environment overrides, or undefined when not needed.
 */
async function resolveCodexEnv(): Promise<Record<string, string> | undefined> {
  const codexHome = process.env.CODEX_HOME ?? path.join(os.homedir(), '.codex');
  const configPath = path.join(codexHome, 'config.toml');
  const configContents = await readCodexConfig(configPath);
  if (!configContents) {
    return undefined;
  }

  if (!configContents.includes('responses_websocket')) {
    return undefined;
  }

  const codexDir = path.join(process.cwd(), '.codex');
  await ensureSafeCodexDir(codexDir);

  const fallbackHome = path.join(codexDir, 'codex-home');
  await mkdir(fallbackHome, { recursive: true });
  const fallbackConfigPath = path.join(fallbackHome, 'config.toml');
  await ensureFallbackConfig(fallbackConfigPath);

  const env = cloneProcessEnv();
  env.CODEX_HOME = fallbackHome;

  process.stderr.write(
    `Detected unsupported wire_api in ${configPath}; using isolated CODEX_HOME at ${fallbackHome}.\n`,
  );

  return env;
}

/**
 * Return the default output schema for delegate responses.
 *
 * @returns {Record<string, unknown>} Schema object for response validation.
 * @remarks
 * This schema is used when no user-provided output schema is supplied.
 * @example
 * const schema = getDefaultOutputSchema();
 */
function getDefaultOutputSchema(): Record<string, unknown> {
  return {
    type: 'object',
    properties: {
      summary: { type: 'string' },
      status: { type: 'string' },
      risks: { type: 'array', items: { type: 'string' } },
      actions: { type: 'array', items: { type: 'string' } },
      nextSteps: { type: 'array', items: { type: 'string' } },
    },
    required: ['summary', 'status'],
    additionalProperties: true,
  } as const;
}

/**
 * Detect and handle the init command, returning whether execution should stop.
 *
 * @param {string[]} argv - Parsed CLI arguments excluding the node and script paths.
 * @returns {boolean} True when init was handled and execution should stop.
 * @remarks
 * This keeps the init flow separate from the main run path to simplify branching.
 * @example
 * if (handleInitCommand(argv)) return;
 */
function handleInitCommand(argv: string[]): boolean {
  if (argv[0] !== 'init') {
    return false;
  }

  ensureCodexConfig();
  return true;
}

/**
 * Ensure required task input is present.
 *
 * @param {DelegateOptions} options - Parsed delegate options.
 * @returns {void} No return value; throws if missing task.
 * @throws {Error} When the task option is missing or empty.
 * @remarks
 * This guard preserves consistent error messaging for CLI consumers.
 * @example
 * ensureTaskProvided(options);
 */
function ensureTaskProvided(options: DelegateOptions): void {
  if (!options.task) {
    throw new Error('Missing required --task value.');
  }
}

/**
 * Validate the requested role against the available prompt templates.
 *
 * @param {string} role - Requested role name.
 * @param {string[]} availableRoles - Available prompt roles on disk.
 * @returns {void} No return value; throws on invalid role selection.
 * @throws {Error} When the role is not available.
 * @remarks
 * When no roles are available, a warning is printed and execution continues.
 * @example
 * validateRoleSelection(options.role, listPromptRoles());
 */
function validateRoleSelection(role: string, availableRoles: string[]): void {
  if (availableRoles.length === 0) {
    process.stderr.write(
      'No roles available in .codex; continuing without role-specific instructions.\n',
    );
    return;
  }

  if (!availableRoles.includes(role)) {
    throw new Error(`Unknown --role "${role}". Available roles: ${availableRoles.join(', ')}.`);
  }
}

/**
 * Resolve logging configuration and optional log stream.
 *
 * @param {DelegateOptions} options - Parsed delegate options.
 * @returns {{ logPath: string; logStream?: ReturnType<typeof createWriteStream>; shouldLog: boolean }} Log setup data.
 * @throws {Error} When the log file path is outside the project directory.
 * @remarks
 * The log stream is opened only when verbose mode or a log file is requested.
 * @example
 * const logSetup = createLogSetup(options);
 */
function createLogSetup(options: DelegateOptions): {
  logPath: string;
  logStream?: ReturnType<typeof createWriteStream>;
  shouldLog: boolean;
} {
  const logPath = options.logFile ?? path.join(process.cwd(), 'codex-delegate.log');
  const shouldLog = options.verbose || Boolean(options.logFile);
  if (!shouldLog) {
    return { logPath, shouldLog };
  }

  const resolved = path.resolve(logPath);
  const relativePath = path.relative(process.cwd(), resolved);
  if (relativePath.startsWith('..') || path.isAbsolute(relativePath)) {
    throw new Error('Log file path must be inside project directory.');
  }

  // eslint-disable-next-line security/detect-non-literal-fs-filename -- resolved path validated and constrained to project files
  const logStream = createWriteStream(resolved, { flags: 'a' });
  return { logPath, logStream, shouldLog };
}

/**
 * Build Codex client options based on CLI flags and environment overrides.
 *
 * @param {DelegateOptions} options - Parsed delegate options.
 * @param {Record<string, string> | undefined} codexEnv - Optional environment overrides.
 * @returns {{ config?: { wire_api: 'responses' }; env?: Record<string, string> }} Codex options object.
 * @remarks
 * The wire_api override is applied unless explicitly disabled.
 * @example
 * const codexOptions = buildCodexOptions(options, codexEnv);
 */
function buildCodexOptions(
  options: DelegateOptions,
  codexEnv: Record<string, string> | undefined,
): {
  config?: { wire_api: 'responses' };
  env?: Record<string, string>;
} {
  const codexOptions: {
    config?: { wire_api: 'responses' };
    env?: Record<string, string>;
  } = {};

  if (options.overrideWireApi !== false) {
    codexOptions.config = { wire_api: 'responses' };
  }

  if (codexEnv) {
    codexOptions.env = codexEnv;
  }

  return codexOptions;
}

/**
 * Resolve the reasoning effort option to the expected literal union.
 *
 * @param {DelegateOptions} options - Parsed delegate options.
 * @returns {ReasoningLevel | undefined} Reasoning effort when provided.
 * @remarks
 * Validation has already guaranteed any provided reasoning value is valid.
 * @example
 * const reasoningArg = resolveReasoningArg(options);
 */
function resolveReasoningArg(options: DelegateOptions): ReasoningLevel | undefined {
  if (!options.reasoning) {
    return undefined;
  }

  return options.reasoning as ReasoningLevel;
}

/**
 * Start a periodic progress reporter when logging is enabled.
 *
 * @param {{ logPath: string; logStream?: ReturnType<typeof createWriteStream> }} logSetup - Logging configuration.
 * @param logSetup.logPath
 * @param logSetup.logStream
 * @returns {NodeJS.Timeout | undefined} Interval handle when started.
 * @remarks
 * The reporter tails the log file and prints the last few lines to stdout.
 * @example
 * const interval = startProgressReporter({ logPath, logStream });
 */
function startProgressReporter(logSetup: {
  logPath: string;
  logStream?: ReturnType<typeof createWriteStream>;
}): NodeJS.Timeout | undefined {
  if (!logSetup.logStream) {
    return undefined;
  }

  const progressIntervalMs = SECONDS_PER_MINUTE * MILLISECONDS_PER_SECOND;
  return setInterval(() => {
    const tail = tailLogFile(logSetup.logPath, LOG_TAIL_LINE_COUNT);
    if (tail.length === 0) {
      return;
    }
    process.stdout.write(
      [`\nSub-agent progress (last ${LOG_TAIL_LINE_COUNT} log lines):`, ...tail].join('\n') + '\n',
    );
  }, progressIntervalMs);
}

type CodexOptions = ReturnType<typeof buildCodexOptions>;

/**
 * Builds a Codex client from the resolved options.
 *
 * @param {CodexOptions} codexOptions - The options to pass to the Codex constructor.
 * @returns {Codex} The constructed Codex client.
 * @remarks
 * This preserves the default constructor behaviour when no options are provided.
 * @example
 * const codex = createCodexClient(options);
 */
function createCodexClient(codexOptions: CodexOptions): Codex {
  return Object.keys(codexOptions).length === 0 ? new Codex() : new Codex(codexOptions);
}

/**
 * Writes the usage summary to stdout if it is available.
 *
 * @param {string | undefined} usageSummary - The optional usage summary to print.
 * @returns {void} No return value.
 * @remarks
 * This keeps output formatting consistent across the CLI.
 * @example
 * emitUsageSummary(results.usageSummary);
 */
function emitUsageSummary(usageSummary: string | undefined): void {
  if (!usageSummary) {
    return;
  }

  process.stdout.write(usageSummary + '\n');
}

/**
 * Stops logging and progress reporting resources.
 *
 * @param {{ logStream?: ReturnType<typeof createWriteStream> }} logSetup - The log setup containing the stream to close.
 * @param logSetup.logStream
 * @param {NodeJS.Timeout | undefined} progressInterval - The optional progress interval to clear.
 * @returns {void} No return value.
 * @remarks
 * This ensures streams and timers are cleaned up even when the run fails.
 * @example
 * finalizeRun(logSetup, progressInterval);
 */
function finalizeRun(
  logSetup: { logStream?: ReturnType<typeof createWriteStream> },
  progressInterval: NodeJS.Timeout | undefined,
): void {
  logSetup.logStream?.end();
  if (progressInterval) {
    clearInterval(progressInterval);
  }
}

/**
 * Primary program runner: parse arguments, initialise Codex thread, stream results and print summaries.
 *
 * @returns {Promise<void>} Resolves when the delegate completes or rejects on fatal errors.
 * @throws {Error} When required options are missing or validations fail.
 * @remarks
 * This function orchestrates argument parsing, schema resolution, Codex thread setup, and streaming result processing. It handles logging setup and progress reporting.
 * @example
 * await run();
 */
async function run(): Promise<void> {
  const argv = process.argv.slice(STARTUP_ARG_OFFSET);
  if (handleInitCommand(argv)) {
    return;
  }

  const options = parseArgs(argv);
  ensureTaskProvided(options);

  const outputSchema = resolveOutputSchema(options, getDefaultOutputSchema());
  validateOptions(options);

  validateRoleSelection(options.role, listPromptRoles());

  const logSetup = createLogSetup(options);

  const codexEnv = await resolveCodexEnv();
  const codexOptions = buildCodexOptions(options, codexEnv);

  const codex = createCodexClient(codexOptions);
  // Ensure the reasoning option is narrowed to the allowed literal union before
  // passing it into the Codex API.
  const reasoningArg = resolveReasoningArg(options);

  const thread = codex.startThread({
    model: options.model,
    modelReasoningEffort: reasoningArg,
    workingDirectory: options.workingDir,
    sandboxMode: options.sandbox,
    approvalPolicy: options.approval,
    networkAccessEnabled: options.network,
    webSearchMode: options.webSearch,
  });

  const prompt = buildPrompt(options);
  const streamed = await thread.runStreamed(prompt, { outputSchema });
  const timeoutMs =
    (options.timeoutMinutes ?? DEFAULT_TIMEOUT_MINUTES) *
    SECONDS_PER_MINUTE *
    MILLISECONDS_PER_SECOND;
  const progressInterval = startProgressReporter(logSetup);

  try {
    const results = await processStream(streamed.events, options, logSetup.logStream, timeoutMs);

    printSummaries(results, options);
    printFinalResponse(results, outputSchema);
    emitUsageSummary(results.usageSummary);
  } finally {
    finalizeRun(logSetup, progressInterval);
  }
}

/**
 * Entrypoint wrapper that executes `run` and normalises uncaught errors to process exit code 1.
 *
 * @returns {Promise<void>} Resolves when `run` completes; on error sets `process.exitCode = 1` and writes the error message to stderr.
 * @remarks
 * This wrapper keeps CLI error handling consistent for end users.
 * @example
 * void main();
 */
async function main(): Promise<void> {
  try {
    await run();
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    process.stderr.write(message + '\n');
    process.exitCode = 1;
  }
}

// Export internal helpers for testing
export {
  applyBooleanOption,
  buildPrompt,
  handleImmediateFlag,
  handleItemCompleted,
  handleTurnCompleted,
  isAgentMessage,
  isBooleanOption,
  isCommandExecution,
  isFileChangeArray,
  isFileChangeItem,
  isMcpToolCall,
  isOption,
  isString,
  isWebSearch,
  listPromptRoles,
  parseArgs,
  parseBoolean,
  printFinalResponse,
  printHelp,
  printSummaries,
  processStream,
  main,
  resolveOutputSchema,
  resolvePromptTemplate,
  run,
  tailLogFile,
  toStreamResults,
  validateOptions,
};
export type { DelegateOptions, ReasoningLevel };

// Run the entrypoint only when not in the test environment to avoid side-effects during imports
if (process.env.NODE_ENV !== 'test') {
  // top-level await is unavailable with CommonJS; call the async entrypoint explicitly
  void main();
}
